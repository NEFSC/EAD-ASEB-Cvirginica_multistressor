var.scale = 1,
groups = as.factor(Day1PCA$pCO2),
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +   ggtitle("day1, pcO2") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Sal <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Salinity,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, salinity") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Temp <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Temp,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, temp") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
ggarrange(p1Sal, p1pCO2, p1Temp, ncol = 3,nrow = 1)
library(ggpubr)
ggarrange(p1Sal, p1pCO2, p1Temp, ncol = 3,nrow = 1)
# data frames and loop sets for the for statement below;
D1_modCols        <- as.data.frame(unique(ModMem_D1$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('black', 'blue', 'brown', 'pink', 'red', 'turquoise')) # yellow and green were NOT significant
meanExp_total     <- data.frame()
meanExp_statsloop <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
meanExp_stats     <- data.frame()
for (i in 1:nrow(D1_modCols)) {
loopModCol     <- D1_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D1 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.6)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D1, by = 'TranscriptID')[,-c(1:3)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
meanExp_total <- rbind(meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
meanExp_statsloop$Day                 <- 1
meanExp_statsloop$modColor            <- loopModCol
meanExp_statsloop$Gene.count          <- nrow(ModMem)
meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(meanExp_statsloop) # name dataframe for this single row
meanExp_stats <- rbind(meanExp_stats,df) #bind to a cumulative list dataframe
print(meanExp_stats) # print to monitor progress
}
meanExp_total_wide <- reshape2::dcast(meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
meanExp_Master     <- merge(d2.Seq_SampleKey, meanExp_total_wide) %>% select(-c(Temperature, OA, Salinity, Age.days))
meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(meanExp_stats[c(4:5)])
# data frames and loop sets for the for statement below;
D1_modCols        <- as.data.frame(unique(ModMem_D1$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('black', 'blue', 'brown', 'pink', 'red', 'turquoise')) # yellow and green were NOT significant
meanExp_total     <- data.frame()
meanExp_statsloop <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
meanExp_stats     <- data.frame()
for (i in 1:nrow(D1_modCols)) {
loopModCol     <- D1_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D1 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.6)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D1, by = 'TranscriptID')[,-c(1:3)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
meanExp_total <- rbind(meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
meanExp_statsloop$Day                 <- 1
meanExp_statsloop$modColor            <- loopModCol
meanExp_statsloop$Gene.count          <- nrow(ModMem)
meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(meanExp_statsloop) # name dataframe for this single row
meanExp_stats <- rbind(meanExp_stats,df) #bind to a cumulative list dataframe
print(meanExp_stats) # print to monitor progress
}
meanExp_total_wide <- reshape2::dcast(meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
meanExp_Master     <- merge(d2.Seq_SampleKey, meanExp_total_wide) %>% select(-c(Temperature, OA, Salinity, Age.days))
meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(meanExp_stats[c(4:5)])
# Run a PCA for Day 1
Master_Day1$Day <- as.factor(Master_Day1$Day) # convert Day into a factor
Day1PCA         <- (merge(Master_Day1, meanExp_Master))[-9,]
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,11:16)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
phys_pca1
summary(phys_pca1)
Day1PCA         <- (merge(Master_Day1, meanExp_Master))
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,11:16)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
summary(phys_pca1)
# data frames and loop sets for the for statement below;
D1_modCols        <- as.data.frame(unique(ModMem_D1$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('black', 'blue', 'brown', 'pink', 'red', 'turquoise')) # yellow and green were NOT significant
meanExp_total     <- data.frame()
meanExp_statsloop <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
meanExp_stats     <- data.frame()
for (i in 1:nrow(D1_modCols)) {
loopModCol     <- D1_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D1 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.4)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D1, by = 'TranscriptID')[,-c(1:3)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
meanExp_total <- rbind(meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
meanExp_statsloop$Day                 <- 1
meanExp_statsloop$modColor            <- loopModCol
meanExp_statsloop$Gene.count          <- nrow(ModMem)
meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(meanExp_statsloop) # name dataframe for this single row
meanExp_stats <- rbind(meanExp_stats,df) #bind to a cumulative list dataframe
print(meanExp_stats) # print to monitor progress
}
meanExp_total_wide <- reshape2::dcast(meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
meanExp_Master     <- merge(d2.Seq_SampleKey, meanExp_total_wide) %>% select(-c(Temperature, OA, Salinity, Age.days))
meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(meanExp_stats[c(4:5)])
# Run a PCA for Day 1
Master_Day1$Day <- as.factor(Master_Day1$Day) # convert Day into a factor
Day1PCA         <- (merge(Master_Day1, meanExp_Master))
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,11:16)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
summary(phys_pca1)
Day1PCA         <- (merge(Master_Day1, meanExp_Master))[-9,]
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,11:16)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,11:16)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
summary(phys_pca1)
# data frames and loop sets for the for statement below;
D1_modCols        <- as.data.frame(unique(ModMem_D1$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('black', 'blue', 'brown', 'pink', 'red', 'turquoise')) # yellow and green were NOT significant
meanExp_total     <- data.frame()
meanExp_statsloop <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
meanExp_stats     <- data.frame()
for (i in 1:nrow(D1_modCols)) {
loopModCol     <- D1_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D1 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.8)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D1, by = 'TranscriptID')[,-c(1:3)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
meanExp_total <- rbind(meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
meanExp_statsloop$Day                 <- 1
meanExp_statsloop$modColor            <- loopModCol
meanExp_statsloop$Gene.count          <- nrow(ModMem)
meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(meanExp_statsloop) # name dataframe for this single row
meanExp_stats <- rbind(meanExp_stats,df) #bind to a cumulative list dataframe
print(meanExp_stats) # print to monitor progress
}
meanExp_total_wide <- reshape2::dcast(meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
meanExp_Master     <- merge(d2.Seq_SampleKey, meanExp_total_wide) %>% select(-c(Temperature, OA, Salinity, Age.days))
meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(meanExp_stats[c(4:5)])
# Run a PCA for Day 1
Master_Day1$Day <- as.factor(Master_Day1$Day) # convert Day into a factor
Day1PCA         <- (merge(Master_Day1, meanExp_Master))[-9,]
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,11:16)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
summary(phys_pca1)
p1pCO2 <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = as.factor(Day1PCA$pCO2),
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +   ggtitle("day1, pCO2") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
Day1PCA         <- (merge(Master_Day1, meanExp_Master))
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,11:16)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
summary(phys_pca1)
colMeans(meanExp_stats[c(4:5)])
# summary: the histogram of cor coeffs for DEGs overlapped with WGCNA module indicates 0.6 as a good cut off
# we confirm here that 0.6 cor coeff and < 0.05 p value can increase explanatory variance relative to 0.4 cor coeff
# however more conservative threshold (0.8) does not make a difference, albeit these (cor coeff cutoffs) change the number of genes contr'ing to the mean by >2 fold!
p1pCO2 <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = as.factor(Day1PCA$pCO2),
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +   ggtitle("day1, pCO2") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Sal <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Salinity,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, salinity") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Temp <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Temp,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, temp") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
library(ggpubr)
ggarrange(p1Sal, p1pCO2, p1Temp, ncol = 3,nrow = 1)
meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
# data frames and loop sets for the for statement below;
D1_modCols        <- as.data.frame(unique(ModMem_D1$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('black', 'blue', 'brown', 'pink', 'red', 'turquoise')) # yellow and green were NOT significant
meanExp_total     <- data.frame()
meanExp_statsloop <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
meanExp_stats     <- data.frame()
for (i in 1:nrow(D1_modCols)) {
loopModCol     <- D1_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D1 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.6)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D1, by = 'TranscriptID')[,-c(1:3)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
meanExp_total <- rbind(meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
meanExp_statsloop$Day                 <- 1
meanExp_statsloop$modColor            <- loopModCol
meanExp_statsloop$Gene.count          <- nrow(ModMem)
meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(meanExp_statsloop) # name dataframe for this single row
meanExp_stats <- rbind(meanExp_stats,df) #bind to a cumulative list dataframe
print(meanExp_stats) # print to monitor progress
}
meanExp_total_wide <- reshape2::dcast(meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
meanExp_Master     <- merge(d2.Seq_SampleKey, meanExp_total_wide) %>% select(-c(Temperature, OA, Salinity, Age.days))
meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(meanExp_stats[c(4:5)])
summarise(sd_Exp = sd(meanExp_stats$Percent_MM.0.05))
meanExp_stats %>% summarise(sd_Exp = sd(meanExp_stats$Percent_MM.0.05))
meanExp_stats %>% summarise(sd_Exp = sd(meanExp_stats$Percent_MM.0.05))
meanExp_stats %>% summarise(sd_Gene_count = sd(meanExp_stats$Gene.count.MM.0.5),
sd_Perc = sd(meanExp_stats$Percent_MM.0.05))
colMeans(meanExp_stats[c(4:5)])
meanExp_stats %>% summarise(sd_Gene_count = sd(meanExp_stats$Gene.count.MM.0.5),
sd_Perc = sd(meanExp_stats$Percent_MM.0.05))
Day1PCA         <- (merge(Master_Day1, meanExp_Master))
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,11:16)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
# summary: the histogram of cor coeffs for DEGs overlapped with WGCNA module indicates 0.6 as a good cut off
# we confirm here that 0.6 cor coeff and < 0.05 p value can increase explanatory variance relative to 0.4 cor coeff
# however more conservative threshold (0.8) does not make a difference, albeit these (cor coeff cutoffs) change the number of genes contr'ing to the mean by >2 fold!
p1pCO2 <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = as.factor(Day1PCA$pCO2),
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +   ggtitle("day1, pCO2") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Sal <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Salinity,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, salinity") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Temp <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Temp,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.5) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, temp") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
library(ggpubr)
ggarrange(p1Sal, p1pCO2, p1Temp, ncol = 3,nrow = 1)
# summary: the histogram of cor coeffs for DEGs overlapped with WGCNA module indicates 0.6 as a good cut off
# we confirm here that 0.6 cor coeff and < 0.05 p value can increase explanatory variance relative to 0.4 cor coeff
# however more conservative threshold (0.8) does not make a difference, albeit these (cor coeff cutoffs) change the number of genes contr'ing to the mean by >2 fold!
p1pCO2 <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = as.factor(Day1PCA$pCO2),
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.67) +
scale_color_discrete(name = '') +  theme_classic() +   ggtitle("day1, pCO2") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Sal <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Salinity,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.67) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, salinity") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Temp <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Temp,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.67) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, temp") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
library(ggpubr)
ggarrange(p1Sal, p1pCO2, p1Temp, ncol = 3,nrow = 1)
d2.Seq_SampleKey
d2.Seq <- read.csv(file="Data/TagSeq/day2.exp.data.csv", sep=',', header=TRUE)
d2.Seq
d2.Seq_SampleKey
read.csv(file="Data/TagSeq/day2.exp.data.csv", sep=',', header=TRUE) %>%
dplyr::rename('SampleID' = 'SapleName_readmatrix') %>%
dplyr::rename('Chamber_tank' = 'ID')
read.csv(file="Data/TagSeq/day2.exp.data.csv", sep=',', header=TRUE)
read.csv(file="Data/TagSeq/day2.exp.data.csv", sep=',', header=TRUE)
read.csv(file="Data/TagSeq/day2.exp.data.csv", sep=',', header=TRUE) %>% dplyr::select(c(2,7))
d2.Aragsat        <- read.csv(file="Data/TagSeq/day2.exp.data.csv", sep=',', header=TRUE) %>%
dplyr::select(c(2,7)) %>%
dplyr::rename('SampleID' = 'SapleName_readmatrix') %>%
dplyr::mutate(Aragonite_saturation = case_when(Aragonite_saturation < 0.5 ~ 'Low',
(Aragonite_saturation > 0.5 & Aragonite_saturation < 1.0) ~ 'Mid',
Aragonite_saturation > 1.0 ~ 'High'))
d2.Aragsat
d2.Seq_SampleKey <- merge(d2.Seq_SampleKey,d2.Aragsat, by = 'SampleID')
d2.Seq_SampleKey
# master phys (merge resp and shell length + survival data )
Master_Days1.8_phys  <- merge(resp_master_RepMean,length_survival_D1.8) %>%  dplyr::mutate(AllTreat = paste(Temp, pCO2, Salinity, sep = ''))
Master_Day1          <- Master_Days1.8_phys %>%  dplyr::filter(Day %in% 1)
Master_Day8          <- Master_Days1.8_phys %>%  dplyr::filter(Day %in% 8)
Master_Days1.8_phys_cors <- Master_Days1.8_phys %>% # Master_Days1.8_phys_cors = corrected for the treatment day - to run PCA regardless of time point!
dplyr::mutate(Length_Cor = ifelse( (Day == 1) | (Day == 8),
Average.Length/mean(Master_Day1$Average.Length),
Average.Length/mean(Master_Day8$Average.Length))) %>%
dplyr::mutate(Surv_Cor = ifelse( (Day == 1) | (Day == 8),
Survival/mean(Master_Day1$Survival),
Survival/mean(Master_Day8$Survival))) %>%
dplyr::mutate(Resp_Cor = ifelse( (Day == 1) | (Day == 8),
mean_resp/mean(Master_Day1$mean_resp),
mean_resp/mean(Master_Day8$mean_resp)))
# Run a PCA for Day 1
Master_Day1$Day <- as.factor(Master_Day1$Day) # convert Day into a factor
Master_Day1
d2.Seq_SampleKey  <- merge(d2.Seq_SampleKey,d2.Aragsat, by = 'SampleID')
ModMem_D1         <- read.csv(file="Output/WGCNA/day2_larvae/d2.WGCNA_ModulMembership.csv", header=T) %>%  na.omit()
# data frames and loop sets for the for statement below;
D1_modCols        <- as.data.frame(unique(ModMem_D1$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('black', 'blue', 'brown', 'pink', 'red', 'turquoise')) # yellow and green were NOT significant
meanExp_total     <- data.frame()
meanExp_statsloop <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
meanExp_stats     <- data.frame()
for (i in 1:nrow(D1_modCols)) {
loopModCol     <- D1_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D1 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.6)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D1, by = 'TranscriptID')[,-c(1:3)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
meanExp_total <- rbind(meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
meanExp_statsloop$Day                 <- 1
meanExp_statsloop$modColor            <- loopModCol
meanExp_statsloop$Gene.count          <- nrow(ModMem)
meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(meanExp_statsloop) # name dataframe for this single row
meanExp_stats <- rbind(meanExp_stats,df) #bind to a cumulative list dataframe
print(meanExp_stats) # print to monitor progress
}
meanExp_total_wide <- reshape2::dcast(meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
meanExp_Master     <- merge(d2.Seq_SampleKey, meanExp_total_wide) %>% select(-c(Temperature, OA, Salinity, Age.days))
meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(meanExp_stats[c(4:5)])
meanExp_stats %>% summarise(sd_Gene_count = sd(meanExp_stats$Gene.count.MM.0.5),
sd_Perc = sd(meanExp_stats$Percent_MM.0.05))
# master phys (merge resp and shell length + survival data )
Master_Days1.8_phys  <- merge(resp_master_RepMean,length_survival_D1.8) %>%  dplyr::mutate(AllTreat = paste(Temp, pCO2, Salinity, sep = ''))
Master_Day1          <- Master_Days1.8_phys %>%  dplyr::filter(Day %in% 1)
Master_Day8          <- Master_Days1.8_phys %>%  dplyr::filter(Day %in% 8)
Master_Days1.8_phys_cors <- Master_Days1.8_phys %>% # Master_Days1.8_phys_cors = corrected for the treatment day - to run PCA regardless of time point!
dplyr::mutate(Length_Cor = ifelse( (Day == 1) | (Day == 8),
Average.Length/mean(Master_Day1$Average.Length),
Average.Length/mean(Master_Day8$Average.Length))) %>%
dplyr::mutate(Surv_Cor = ifelse( (Day == 1) | (Day == 8),
Survival/mean(Master_Day1$Survival),
Survival/mean(Master_Day8$Survival))) %>%
dplyr::mutate(Resp_Cor = ifelse( (Day == 1) | (Day == 8),
mean_resp/mean(Master_Day1$mean_resp),
mean_resp/mean(Master_Day8$mean_resp)))
# Run a PCA for Day 1
Master_Day1$Day <- as.factor(Master_Day1$Day) # convert Day into a factor
Day1PCA         <- (merge(Master_Day1, meanExp_Master))[-9,]
Day1PCA
Day1PCA         <- (merge(Master_Day1, meanExp_Master))
Day1PCA
# PCA Day 1
phys_pca1   <- prcomp(Day1PCA[,c(3,7,8,13:18)], # all numeric (phys + all modules) - PCA 1 = 0.4133 , PCA 2 0.1786  (cumulative 0.5919)
center = TRUE,
scale. = TRUE)
summary(phys_pca1)
p1Arag <- ggbiplot(phys_pca1,
obs.scale = 1,
var.scale = 1,
groups = Day1PCA$Aragonite_saturation.y,
ellipse = TRUE,
circle = TRUE,
ellipse.prob = 0.67) +
scale_color_discrete(name = '') +  theme_classic() +  ggtitle("day1, temp") +
theme(legend.direction = 'horizontal',
legend.position = 'top')
p1Arag
