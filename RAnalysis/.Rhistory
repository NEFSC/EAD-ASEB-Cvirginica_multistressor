# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.6)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D22, by = 'TranscriptID')[,-c(1:4)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
D22_meanExp_total <- rbind(D22_meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(D22_meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
D22_meanExp_statsloop$Day                 <- 1
D22_meanExp_statsloop$modColor            <- loopModCol
D22_meanExp_statsloop$Gene.count          <- nrow(ModMem)
D22_meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
D22_meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(D22_meanExp_statsloop) # name dataframe for this single row
D22_meanExp_stats <- rbind(D22_meanExp_stats,df) #bind to a cumulative list dataframe
print(D22_meanExp_stats) # print to monitor progress
}
D22_meanExp_total_wide <- reshape2::dcast(D22_meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
D22_meanExp_Master     <- merge(d22.Seq_SampleKey, D22_meanExp_total_wide) %>%
dplyr::mutate(pCO2 = substr(OA, 1,1)) %>%
dplyr::mutate(Salinity = substr(Salinity,1,1)) %>%
dplyr::mutate(Temp = substr(Temperature,1,1)) %>%
select(-c(Temperature, OA, Age.days)) %>%
dplyr::rename(Sample.ID = Chamber_tank)
D22_meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(D22_meanExp_stats[c(4:5)]) # 364.50000          70.95545
D22_meanExp_stats %>% summarise(sd_Gene_count = sd(D22_meanExp_stats$Gene.count.MM.0.5),
sd_Perc = sd(D22_meanExp_stats$Percent_MM.0.05))
nrow(ModMem)
ModMem
# LOAD PACKAGES
library(WGCNA) # note: this was previously installed with the command `BiocManager::install("WGCNA")`
library(dplyr)
library(zoo)
library(DESeq2)
# for heatmap
# library(devtools)
# install_github("jokergoo/ComplexHeatmap") first run these - commented out to avoid running a second time...
library(ComplexHeatmap)
library(circlize)
library(reshape)
library(ggplot2)
library(hrbrthemes)
# SET WORKING DIRECTORY AND LOAD DATA
setwd("C:/Users/samjg/Documents/Github_repositories/Cvirginica_multistressor/RAnalysis")
d18.filtered_count_tble  <- read.csv(file="Data/TagSeq/Filtered_counts/filtered_counts_5cpm_50perc/day18.filtered_5cpm50perc.csv", sep=',', header=TRUE)
d18.data_matrix <- data.frame(d18.filtered_count_tble[,-1], row.names=d18.filtered_count_tble[,1])
dim(d18.data_matrix) # 4936   11 - 11 samples and 4820 total genes
d18.Treatment.data <- read.csv(file="Data/TagSeq/day18.exp.data.csv", sep=',', header=TRUE) %>%
dplyr::mutate_if(is.character, as.factor) %>%
dplyr::rename('Sample.Name' = 'SapleName_readmatrix') %>%
dplyr::rename('pCO2' = 'OA') %>%
dplyr::select(c('Sample.Name','Temperature','pCO2','Salinity', 'Aragonite_saturation')) %>%
dplyr::mutate(All_treatment = paste( (substr(Temperature,1,1)),
(substr(pCO2,1,1)),
(substr(Salinity,1,1)), sep = '')) %>%
dplyr::mutate(pCO2_Salinity = substr(All_treatment, 2,3)) %>%
dplyr::mutate(Aragonite_saturation = case_when(Aragonite_saturation < 0.5 ~ 'Low',
(Aragonite_saturation > 0.5 & Aragonite_saturation < 1.0) ~ 'Mid',
Aragonite_saturation > 1.0 ~ 'High'))
dim(d18.Treatment.data)[1] ==  dim(d18.data_matrix)[2]# TRUE - each contains all 36 samples sequenced for Day 18 of the experiment
# NOTE: ~1 stands for no design; user will need to add a design for differential testing
# however for our purpose of just creating an object to transform, we do not need a design here...
dds.d18 <- DESeqDataSetFromMatrix(countData = d18.data_matrix,
colData = d18.Treatment.data, design = ~ 1) # DESeq Data Set (dds)
dds.d18 # view the DESeqDataSet - notice the colData containg our critical treatment and sample ID data, rownames, etc.
# transform the data  ========================================================== #
# run in order (kept name as dds.d18_vst)
dds.d18_vst <- vst(dds.d18) # transform it vst (variance stabilized transformation)
dds.d18_vst <- assay(dds.d18_vst) # call only the transformed coutns in the dds object
#fix(dds.d18_vst)
dds.d18_vst <- t(dds.d18_vst) # transpose columns to rows and vice versa
# checks before we start....
dim(dds.d18_vst) #  4936 genes; 11  samples
gsg = goodSamplesGenes(dds.d18_vst, verbose = 3);  # We first check for genes and samples with too many missing values:
gsg$allOK # If the statement returns TRUE, all genes have passed the cuts.
# call the cluster and set window dimenstions to view..
sampleTree = hclust(dist(dds.d18_vst), method = "average") # Next we cluster the samples (in contrast to clustering genes that will come later)  to see if there are any obvious outliers.
sizeGrWindow(12,9) # The user should change the dimensions if the window is too large or too small.
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2) # appears there are two outliers SG59; can remove by hand or an automatic appraoch
# cut the tree and omit  ========================================================== #
clust = cutreeStatic(sampleTree, cutHeight = 35, minSize = 10) # Determine cluster under the line
table(clust) # 0 = cut; 1 = kept; says it will cut 1 and save 35; exactly what we want!
keepSamples = (clust==1) # 'keepsamples' boolean to call the main dataset - notice there are TWO occurrences of FALSE - these are C6.larva and B12.larva
# integrate keepsamples  ========================================================== #
dds.d18_vst = dds.d18_vst[keepSamples, ] # integrate the boolean 'keepsamples' to omit outliers determined in the sample tree above
nGenes = ncol(dds.d18_vst) # number of genes == 4936
nSamples = nrow(dds.d18_vst) # number of samples == 10  - the cut tree removed 1 sample
# plot the tree with the 'keep samples'  =========================================== #
sampleTree2 = hclust(dist(dds.d18_vst), method = "average") # Next we cluster the samples (in contrast to clustering genes that will come later)  to see if there are any obvious outliers.
plot(sampleTree2, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
# based on outlier removal... call Trait data ===================================================== #
dim(dds.d18_vst) # 10 4936- transformed count data now  has 35 samples - 1 cut in the tree step above
dim(d18.Treatment.data) # 11 6 - trait data has 11  samples - not yet cut!
# Form a data frame analogous to expression data that will hold the clinical traits.
d18.Samples    = rownames(dds.d18_vst); # start new variable 'd18.Samples' calling the row names of the gene data (sample as 'Mouse' in trait data)
TreatRows      = match(d18.Samples, d18.Treatment.data$Sample.Name); # match the names - calls the list number of 'd18.Samples' matching 'd18.Treatment.data$Sample.Name'
d18.Traits     = d18.Treatment.data[TreatRows, -1]; # insert TreatRows as the row numbers in 'd18.Treatment.data'
rownames(d18.Traits)     = d18.Treatment.data[TreatRows, 1]; # inserts the new TreatRows - matches sample IDs
all(rownames(d18.Traits) == rownames(dds.d18_vst)) # should be TRUE
dim(d18.Traits) # 10 Samples 5 columns; now we have 22 samples! - colnames are all treatment, primary and second treatment
d18.Traits
# Salinity groups  ===================================================== #
d18.Traits.Salinity      <-  d18.Traits %>% dplyr::select('Salinity')  %>% # primary treatment as Ambient (A) vs. Moderate (M)
dplyr::mutate(High = as.factor(as.numeric(Salinity == "High")))  %>%  # call occurrence of 'A' as 0s and 1s (factor)
dplyr::mutate(Low = as.factor(as.numeric(Salinity == "Low")))    %>%  # call occurrence of 'M'  as 0s and 1s (factor)
dplyr::select(-Salinity)
d18.Traits.Salinity  # final dataset of 0,1 for treatment groups - Primary only!
# pCO2 groups  ===================================================== #
d18.Traits.pCO2          <-  d18.Traits %>% dplyr::select('pCO2')  %>% # primary treatment as Ambient (A) vs. Moderate (M)
dplyr::mutate(High = as.factor(as.numeric(pCO2 == "High")))  %>%  # call occurrence of 'A' as 0s and 1s (factor)
dplyr::mutate(Low = as.factor(as.numeric(pCO2 == "Low")))    %>%  # call occurrence of 'M'  as 0s and 1s (factor)
dplyr::select(-pCO2)
d18.Traits.pCO2  # final dataset of 0,1 for treatment groups - Primary only!
# aragonite saturation groups  ===================================================== #
d18.Traits.AragoniteSat <-  d18.Traits %>% dplyr::select('Aragonite_saturation')  %>% # primary treatment as Ambient (A) vs. Moderate (M)
dplyr::mutate(High = as.factor(as.numeric(Aragonite_saturation == "High")))  %>%  # call occurrence of 'A' as 0s and 1s (factor)
dplyr::mutate(Mid = as.factor(as.numeric(Aragonite_saturation == "Mid")))    %>%  # call occurrence of 'M'  as 0s and 1s (factor)
dplyr::mutate(Low = as.factor(as.numeric(Aragonite_saturation == "Low")))    %>%  # call occurrence of 'M'  as 0s and 1s (factor)
dplyr::select(-Aragonite_saturation)
d18.Traits.AragoniteSat  # final dataset of 0,1 for treatment groups - Primary only!
# oCO2_Salinity (as _ _ pCO2 and salinity)  ================================================================ #
d18.Traits.pCO2Salinity   <- d18.Traits %>%
dplyr::select('pCO2_Salinity') %>% # primary treatment as Ambient (A) vs. Moderate (M)
dplyr::mutate(HH = as.factor(as.numeric(pCO2_Salinity == "HH")))  %>%  # call occurrence of 'AA' as 0s and 1s (factor)
dplyr::mutate(HL = as.factor(as.numeric(pCO2_Salinity == "HL")))  %>%  # call occurrence of 'AA' as 0s and 1s (factor)
dplyr::mutate(LL = as.factor(as.numeric(pCO2_Salinity == "LL")))  %>%  # call occurrence of 'AA' as 0s and 1s (factor)
dplyr::mutate(LH = as.factor(as.numeric(pCO2_Salinity == "LH")))  %>%  # call occurrence of 'AA' as 0s and 1s (factor)
dplyr::select(-pCO2_Salinity)
d18.Traits.pCO2Salinity
# all treatment grousp (as _ _ _ for temp, pCO2 and salinity)  ================================================================ #
d18.Traits.Group         <- d18.Traits %>%
dplyr::select(c('pCO2_Salinity','Aragonite_saturation')) %>%
dplyr::mutate(pCO2_Sal_Arag = paste(pCO2_Salinity, substr(Aragonite_saturation, 1,1), sep = '')) %>%
dplyr::mutate(HHM = as.factor(as.numeric(pCO2_Sal_Arag == "HHM")))  %>%  # call occurrence of 'AA' as 0s and 1s (factor)
dplyr::mutate(HLL = as.factor(as.numeric(pCO2_Sal_Arag == "HLL")))  %>%  # call occurrence of 'AA' as 0s and 1s (factor)
dplyr::mutate(LHH = as.factor(as.numeric(pCO2_Sal_Arag == "LHH")))  %>%  # call occurrence of 'AA' as 0s and 1s (factor)
dplyr::mutate(LLM = as.factor(as.numeric(pCO2_Sal_Arag == "LLM")))  %>%  # call occurrence of 'AA' as 0s and 1s (factor)
dplyr::select(-c('pCO2_Sal_Arag', 'pCO2_Salinity','Aragonite_saturation'))
d18.Traits.Group
traitColors_pCO2 = labels2colors(d18.Traits.pCO2); # Convert traits to a color representation: white means low, red means high, grey means missing entry
plotDendroAndColors(sampleTree2, traitColors_pCO2, # Plot the sample dendrogram and the colors underneath.
groupLabels = names(d18.Traits.pCO2),
main = "Sample dendrogram and trait heatmap (pCO2)")
dim(dds.d18_vst) #  22 4820 - again double check you have the correct data...
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(dds.d18_vst, powerVector = powers, verbose = 5) #...wait for this to finish
par(mfrow = c(1,2));
cex1 = 0.9;
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], # Scale-free topology fit index as a function of the soft-thresholding power
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
abline(h=0.90,col="red") # look at at cut off at power of 3 - this line corresponds to using an R^2 cut-off of h
plot(sft$fitIndices[,1], sft$fitIndices[,5], # Mean connectivity as a function of the soft-thresholding power
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
#=====================================================================================
#
#  Satrt the step-wise module construction:
# Step 1 = create adjacency matrix
# https://peterlangfelder.com/2018/11/25/signed-or-unsigned-which-network-type-is-preferable/
# https://www.rdocumentation.org/packages/WGCNA/10cpm/versions/1.69/topics/adjacency
# https://ramellose.github.io/networktutorials/wgcna.html
# https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/10cpm/TechnicalReports/signedTOM.pdf
#=====================================================================================
softPower = 12 # set your soft threshold based on the plots above
# signed - must call te type, defaults to unsigned
adjacency_sign = adjacency(dds.d18_vst, power = softPower, type="signed") # this takes a long time.. just wait...
# signed matrix
TOM_sign       = TOMsimilarity(adjacency_sign, TOMType="signed")  # this takes a long time.. just wait...
dissTOM_sign   = 1-TOM_sign
source("~/Github_repositories/Cvirginica_multistressor/RAnalysis/Scripts/WGCNA_d22_spat.R", echo=TRUE)
#=====================================================================================
#
#  Step 3:Call the hierarchical clustering function - plot the tree
#
#=====================================================================================
# Call the hierarchical clustering function
geneTree_sign   = hclust(as.dist(dissTOM_sign), method = "average");
plot(geneTree_sign, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity - SIGNED",
labels = FALSE, hang = 0.04);
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 100; # set this for the subseqent call - WGCNA authors recomend diligence when calling module size to avoid too many/too few modules...
# Module identification using dynamic tree cut:
dynamicMods_sign = cutreeDynamic(dendro = geneTree_sign, distM = dissTOM_sign,
deepSplit = 1, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize);
table(dynamicMods_sign) # view the number of genes per module
# Convert numeric lables into colors
dynamicColors_sign = labels2colors(dynamicMods_sign) # add colors to module labels (previously numbers)
table(dynamicColors_sign) # lets look at this table...
# MEList = moduleEigengenes(dds.d18_vst, colors = dynamicColors)
MEList = moduleEigengenes(dds.d18_vst, colors = dynamicColors_sign)
MEs    = MEList$eigengenes # you can view MEs, condenses gene counts down to a single number for each sample representive of that expressoin pattern
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
METree = hclust(as.dist(MEDiss), method = "average") # Cluster module eigengenes
plot(METree, main = "Clustering of module eigengenes - SIGNED (dissimilarity calc = MEDiss = 1-cor(MEs))",
xlab = "", sub = "") +
abline(h=0.3, col = "red") # add the line to the tree
# change the cut height for the eignengene tree!
MEDissThres = 0.3 # call the cut height
# save with the abline added
plot(METree, main = "Clustering of module eigengenes (dissimilarity calc = MEDiss = 1-cor(MEs))",
xlab = "", sub = "") +
abline(h=MEDissThres, col = "red") # add the line to the tree
# Call an automatic merging function
merge = mergeCloseModules(dds.d18_vst, dynamicColors_sign, cutHeight = MEDissThres, verbose = 3) # signed TOM
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;
# Calculate dissimilarity of module eigengenes
MEDiss_merged = 1-cor(mergedMEs);
METree_merged = hclust(as.dist(MEDiss_merged), method = "average") # Cluster module eigengenes
# count of merged eigengene modules
table(merge$colors)
# black        blue       brown        cyan       green greenyellow     magenta      purple         red      salmon         tan   turquoise
# 237         808         568         140         516         178         198         194         277         602         178        1040
nrow(geneInfo_GROUPS %>% dplyr::filter(moduleColor %in% 'blue' & p.MM.blue < 0.05))
geneInfo_GROUPS
METree_merged
mergedMEs
#=====================================================================================
#
#  Step 9: Commit to mergedcolors as 'MEs' and 'moduleColors'
#
#=====================================================================================
# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
moduleLabels
mergedMEs
dds.d18_vst
moduleLabels
moduleColors
# Save module colors and labels for use in subsequent parts
save(mergedMEs, dds.d18_vst, moduleLabels, moduleColors, file = "Output/WGCNA/day18_spat/day18-networkConstruction-stepByStep.RData")
# write csv - save the module eigengenes
write.csv(mergedMEs, file = "Output/WGCNA/day18_spat/d18.WGCNA_ModulEigengenes.csv")
mergedMEs
load("Output/WGCNA/day18_spat/day18-networkConstruction-stepByStep.RData")
# Define numbers of genes and samples
nGenes   = ncol(dds.d18_vst); # 4936
nSamples = nrow(dds.d18_vst); # 10
# Recalculate MEs with color labels
MEs0           <-  read.csv("Output/WGCNA/day18_spat/d18.WGCNA_ModulEigengenes.csv") # read merged eigengene dataset
rownames(MEs0) <- MEs0[,1] # make first column into row names
MEs0           <- MEs0[,-1] # omit the first column (now inserted as rownames...)
MEs = orderMEs(MEs0) # reorders the columns (colors/modules)
MEs0
dim(d18.Traits)  # 10 6
dim(MEs)  # 10 12
table(dynamicColors_sign) # lets look at this table...
#=====================================================================================
#
# Module eigengene -  MEs boxplots by treatment group
#
#=====================================================================================
MEs_table             <- mergedMEs # new table for plotting
MEs_table$Sample.Name <- rownames(mergedMEs) # call rows as coolumn to merge with treatment data
MEsPlotting           <- merge(d18.Treatment.data, MEs_table, by = 'Sample.Name')  %>%
dplyr::select(-c('Temperature','pCO2_Salinity')) # ommit the all treatments column
MEsPlotting_melt      <- reshape2::melt(MEsPlotting, id=c('Sample.Name', 'pCO2', 'Salinity', 'Aragonite_saturation', 'All_treatment'))
MEsPlotting_melt
# We quantify associations of individual genes with our trait of interest (TAOC)
load("Output/WGCNA/day18_spat/day18-networkConstruction-stepByStep.RData")
# names (colors) of the modules
modNames = substring(names(mergedMEs), 3) # name all the modules, from 3rd character on (first two are ME)
geneModuleMembership = as.data.frame(cor(dds.d18_vst, mergedMEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
# HHM treatment group
HHM = as.data.frame(as.numeric(d18.Traits.Group$HHM)); # Define variable containing the desired column
names(HHM) = "HHM"
HHM_geneTraitSignificance = as.data.frame(cor(dds.d18_vst, HHM, use = "p"));
HHM_GSPvalue = as.data.frame(corPvalueStudent(as.matrix(HHM_geneTraitSignificance), nSamples));
names(HHM_geneTraitSignificance) = paste("GS.", names(HHM), sep=""); # MA_geneTraitSignificance - pearsons correlation between reads and the MA grop
names(HHM_GSPvalue) = paste("p.GS.", names(HHM), sep=""); # corPvalueStudent
geneInfo_GROUPS = data.frame(geneSymbol       = annot$Cvirginica_GeneID[probes2annot],
TranscriptID     = annot$Cvirginica_TranscriptID[probes2annot],
moduleColor      = moduleColors,
KEGG_ID          = annot$Cgigas_KEGGID[probes2annot],
Protein_name     = annot$Cvirginica_Protein_name[probes2annot],
gene_length      = annot$Cvirginica_length[probes2annot],
GO.terms         = annot$Annotation_GO_ID[probes2annot],
HHM_geneTraitSignificance, HHM_GSPvalue)
# Should return 0.
#=====================================================================================
#
#  BUILD GENE INFO DATAFRAMES
#
#=====================================================================================
# Create the starting data frame
names(annot)
#=====================================================================================
#
#  Call annotation data to get module gene data (prep for downstream GO)
#
#=====================================================================================
annot = read.csv(file = "Data/TagSeq/Seq_details/Seq_Reference_Master.csv",header = T)
dim(annot) # 59089     6
names(annot) # view the column names to call
probes = names(as.data.frame(t(d18.data_matrix[, -(1)])))
probes2annot = match(probes, annot$Cvirginica_TranscriptID)
# The following is the number or probes without annotation:
sum(is.na(probes2annot)) # 380
# Should return 0.
#=====================================================================================
#
#  BUILD GENE INFO DATAFRAMES
#
#=====================================================================================
# Create the starting data frame
names(annot)
geneInfo_GROUPS = data.frame(geneSymbol       = annot$Cvirginica_GeneID[probes2annot],
TranscriptID     = annot$Cvirginica_TranscriptID[probes2annot],
moduleColor      = moduleColors,
KEGG_ID          = annot$Cgigas_KEGGID[probes2annot],
Protein_name     = annot$Cvirginica_Protein_name[probes2annot],
gene_length      = annot$Cvirginica_length[probes2annot],
GO.terms         = annot$Annotation_GO_ID[probes2annot],
HHM_geneTraitSignificance, HHM_GSPvalue)
modOrder = order(-abs(cor(mergedMEs, HHM, use = "p"))); # order by the strength of the correlation between module and trait values for each sample
for (mod in 1:ncol(geneModuleMembership)) { # Add module membership information in the chosen order
oldNames = names(geneInfo_GROUPS)
geneInfo_GROUPS = data.frame(geneInfo_GROUPS, geneModuleMembership[, modOrder[mod]],
MMPvalue[, modOrder[mod]]);
names(geneInfo_GROUPS) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo_GROUPS$moduleColor, -abs(geneInfo_GROUPS$GS.HHM));
geneInfo_GROUPS = geneInfo_GROUPS[geneOrder, ]
geneInfo_GROUPS
nrow(geneInfo_GROUPS %>% filter(moduleColor %in% 'black'))
nrow(geneInfo_GROUPS %>% filter(moduleColor %in% 'turquoise'))
write.csv(geneInfo_GROUPS, file = "Output/WGCNA/day18_spat/d18.WGCNA_ModulMembership.csv")
ModMem_D22         <- read.csv(file="Output/WGCNA/day18_spat/d18.WGCNA_ModulMembership.csv", header=T) %>%  na.omit()
# data frames and loop sets for the for statement below;
D22_modCols            <- as.data.frame(unique(ModMem_D22$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('blue', 'red', 'salmon', 'tan', 'green', 'turquoise')) # yellow and green were NOT significant
D22_meanExp_total      <- data.frame()
D22_meanExp_statsloop  <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(D22_meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
D22_meanExp_stats      <- data.frame()
for (i in 1:nrow(D22_modCols)) {
loopModCol     <- D22_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D22 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.6)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D22, by = 'TranscriptID')[,-c(1:4)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
D22_meanExp_total <- rbind(D22_meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(D22_meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
D22_meanExp_statsloop$Day                 <- 1
D22_meanExp_statsloop$modColor            <- loopModCol
D22_meanExp_statsloop$Gene.count          <- nrow(ModMem)
D22_meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
D22_meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(D22_meanExp_statsloop) # name dataframe for this single row
D22_meanExp_stats <- rbind(D22_meanExp_stats,df) #bind to a cumulative list dataframe
print(D22_meanExp_stats) # print to monitor progress
}
nrow(ModMem_D22 %>% filter(moduleColor %in% 'turquoise'))
nrow(geneInfo_GROUPS %>% filter(moduleColor %in% 'turquoise'))
write.csv(geneInfo_GROUPS, file = "Output/WGCNA/day18_spat/d18.WGCNA_ModulMembership.csv")
ModMem_D22         <- read.csv(file="Output/WGCNA/day18_spat/d18.WGCNA_ModulMembership.csv", header=T)
nrow(ModMem_D22 %>% filter(moduleColor %in% 'turquoise'))
# data frames and loop sets for the for statement below;
D22_modCols            <- as.data.frame(unique(ModMem_D22$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('blue', 'red', 'salmon', 'tan', 'green', 'turquoise')) # yellow and green were NOT significant
D22_meanExp_total      <- data.frame()
D22_meanExp_statsloop  <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(D22_meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
D22_meanExp_stats      <- data.frame()
for (i in 1:nrow(D22_modCols)) {
loopModCol     <- D22_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D22 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.6)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D22, by = 'TranscriptID')[,-c(1:4)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
D22_meanExp_total <- rbind(D22_meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(D22_meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
D22_meanExp_statsloop$Day                 <- 1
D22_meanExp_statsloop$modColor            <- loopModCol
D22_meanExp_statsloop$Gene.count          <- nrow(ModMem)
D22_meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
D22_meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(D22_meanExp_statsloop) # name dataframe for this single row
D22_meanExp_stats <- rbind(D22_meanExp_stats,df) #bind to a cumulative list dataframe
print(D22_meanExp_stats) # print to monitor progress
}
D22_meanExp_total_wide <- reshape2::dcast(D22_meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
D22_meanExp_Master     <- merge(d22.Seq_SampleKey, D22_meanExp_total_wide) %>%
dplyr::mutate(pCO2 = substr(OA, 1,1)) %>%
dplyr::mutate(Salinity = substr(Salinity,1,1)) %>%
dplyr::mutate(Temp = substr(Temperature,1,1)) %>%
select(-c(Temperature, OA, Age.days)) %>%
dplyr::rename(Sample.ID = Chamber_tank)
D22_meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(D22_meanExp_stats[c(4:5)]) # 364.50000          70.95545
D22_meanExp_stats %>% summarise(sd_Gene_count = sd(D22_meanExp_stats$Gene.count.MM.0.5),
sd_Perc = sd(D22_meanExp_stats$Percent_MM.0.05))
# get full mean of d1 and d22
colMeans(rbind((D1_meanExp_stats[c(4:5)]),(D22_meanExp_stats[c(4:5)])) # 364.50000          70.95545 + - 4.791734
(D1_meanExp_stats[c(4:5)])
# get full mean of d1 and d22
colMeans(rbind((meanExp_stats[c(4:5)]),(D22_meanExp_stats[c(4:5)])) # 364.50000          70.95545 + - 4.791734
# get full mean of d1 and d22
colMeans(rbind((meanExp_stats[c(4:5)]),(D22_meanExp_stats[c(4:5)]))) # 364.50000          70.95545 + - 4.791734
(meanExp_stats[c(4:5)])
(D22_meanExp_stats[c(4:5)])
rbind((meanExp_stats[c(4:5)]),(D22_meanExp_stats[c(4:5)]))
colMeans(rbind((meanExp_stats[c(4:5)]),(D22_meanExp_stats[c(4:5)])))
rbind((meanExp_stats[c(4:5)]),(D22_meanExp_stats[c(4:5)])) %>%
dplyr::summarise(sd_Gene_count = sd(Gene.count.MM.0.5),
sd_Perc = sd(Percent_MM.0.05))
# get full mean of d1 and d22
colMeans(rbind((meanExp_stats[c(4:5)]),(D22_meanExp_stats[c(4:5)]))) # 56.17219           70.95545 + - 4.791734
ModMem_0.05
ModMem_outliers    <- ModMem %>%
dplyr::filter(.[[3]] > 0.05 & .[[4]] > 0.6)
ModMem_outliers
ModMem_outliers    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] < 0.6)
ModMem_outliers
ModMem_outliers    <- ModMem %>%
dplyr::filter(.[[4]] < 0.6)
ModMem_outliers
ModMem_D1         <- read.csv(file="Output/WGCNA/day2_larvae/d2.WGCNA_ModulMembership.csv", header=T) #%>%  na.omit()
# data frames and loop sets for the for statement below;
D1_modCols        <- as.data.frame(unique(ModMem_D1$moduleColor)) %>% dplyr::filter(.[[1]] %in% c('black', 'blue', 'brown', 'pink', 'red', 'turquoise')) # yellow and green were NOT significant
meanExp_total     <- data.frame()
meanExp_statsloop <- data.frame(matrix(nrow = 1, ncol = 5)) # create dataframe to save cumunalitively during for loop
colnames(meanExp_statsloop) <- c('Day', 'modColor', 'Gene.count', 'Gene.count.MM<0.5', 'Percent_MM<0.05') # names for comuns in the for loop
meanExp_stats     <- data.frame()
for (i in 1:nrow(D1_modCols)) {
loopModCol     <- D1_modCols[i,]
loopModCol_cor <- paste("MM.", loopModCol, sep = '')
loopModCol_p   <- paste("p.MM.", loopModCol, sep = '')
# all modules per mod color (with significant eigengene-treatment interaction) - no Module Membership threshold
ModMem         <- ModMem_D1 %>%
dplyr::select(c('TranscriptID',moduleColor, loopModCol_p, loopModCol_cor)) %>%
dplyr::filter(moduleColor %in% loopModCol)
# all modules per mod color (with significant eigengene-treatment interaction) - Module Membership p < 0.05 based on DEG overalap (view R script)
ModMem_0.05    <- ModMem %>%
dplyr::filter(.[[3]] < 0.05 & .[[4]] > 0.6)
MM_0.5_meanExp <- as.data.frame(colMeans(merge(ModMem_0.05, rlog_WGCNA_D1, by = 'TranscriptID')[,-c(1:4)])) %>%  # mean expression by sampleID for this reduced gene pool (Module membership p < 0.05)
dplyr::mutate(modcolor = loopModCol) %>%
tibble::rownames_to_column("SampleID") %>%
dplyr::rename(meanExp = 2)
# print this loop Rbdin for each module
meanExp_total <- rbind(meanExp_total,MM_0.5_meanExp) #bind to a cumulative list dataframe
print(meanExp_total) # print to monitor progress
# print stats for each module - these will assist stats for the 0.05 threshold
meanExp_statsloop$Day                 <- 1
meanExp_statsloop$modColor            <- loopModCol
meanExp_statsloop$Gene.count          <- nrow(ModMem)
meanExp_statsloop$`Gene.count.MM<0.5` <- nrow(ModMem_0.05)
meanExp_statsloop$`Percent_MM<0.05`   <- (nrow(ModMem_0.05) / nrow(ModMem)) * 100
df            <- data.frame(meanExp_statsloop) # name dataframe for this single row
meanExp_stats <- rbind(meanExp_stats,df) #bind to a cumulative list dataframe
print(meanExp_stats) # print to monitor progress
# Day  modColor Gene.count Gene.count.MM.0.5 Percent_MM.0.05
# 1     black        378               177        46.82540
# 1      blue        706               296        41.92635
# 1     brown        678               337        49.70501
# 1      pink        362               139        38.39779
# 1       red        490               195        39.79592
# 1 turquoise        829               296        35.70567
}
meanExp_total_wide <- reshape2::dcast(meanExp_total, SampleID ~ modcolor, value.var="meanExp") # convert to wide format to merge for OCA analysis with physiological variables
meanExp_Master     <- merge(d2.Seq_SampleKey, meanExp_total_wide) %>%
select(-c(Temperature, OA, Salinity, Age.days)) %>%
dplyr::rename(Sample.ID = Chamber_tank)
meanExp_stats # percent contribution of Module member threshold cutoff to the total module membership
colMeans(meanExp_stats[c(4:5)]) # 42.05936 +- 5.293175
